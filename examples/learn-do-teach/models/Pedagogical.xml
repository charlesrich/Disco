<taskModel about="urn:disco.wpi.edu:ldt:Pedagogical"
           xmlns="http://www.cs.wpi.edu/~rich/cetask/cea-2018-ext">
  
  <!-- 
       This is the pedagogical model for the proof of concept system in
       a proposal submitted to the National Science Foundation
       in November, 2015, titled:

       A Unified Theory of Learning, Doing and Teaching Hierarchical Tasks:
       The Learn-Do-Teach Challenge for Collaborative Agents

       See Learn-Do-Teach.pdf (especially Figure 4) for technical discussion
       and test folder for test cases.

       See ABC.xml for the task model being learned.
  -->

  <!-- note 'task' is a reserved slot name in ANSI/CEA-2018, so 'action'
       is used instead below -->
       
  <task id="LearnRecipe">
    <input name="action" type="TaskClass"/>
    <input name="recipe" type="DecompositionClass"/>
    <input name="learner" type="boolean"/>

    <subtasks id="steps">
      <!-- maxOccurs should be 'unbounded', but not fully supported yet -->
      <step name="step" task="LearnStep" maxOccurs="5"/>
      <binding slot="$step.recipe" value="$this.recipe"/>
      <binding slot="$step.learner" value="$this.learner"/>
    </subtasks>

  </task>

  <task id="LearnStep">
    <input name="action" type="TaskClass"/>
    <input name="recipe" type="DecompositionClass"/>
    <input name="learner" type="boolean"/>
    <binding slot="$this.action"
             value="($plan != null &amp;&amp; $this.recipe != undefined) ? 
                    $this.recipe.steps[$plan.getRepeatStep()] : undefined"/>
    <precondition>
      ($plan != null &amp;&amp; $this.recipe != undefined &amp;&amp; $this.recipe.isCompiled() ) ? 
       ($this.recipe.steps[$plan.getRepeatStep()] != undefined) : undefined
    </precondition>

    <subtasks id="instruction">
      <step name="learn" task="addStep"/>
      <binding slot="$learn.action" value="$this.action"/>
      <binding slot="$learn.recipe" value="$this.recipe"/>
      <binding slot="$learn.external" value="$this.learner"/>
    </subtasks>

    <subtasks id="demonstration">
      <!-- note unrestricted step task type -->
      <step name="demonstrate"/>
      <step name="learn" task="addStep"/>
      <applicable> $this.action.isPrimitive() </applicable>
      <binding slot="$demonstrate.type"
               value="$disco.getTaskClass($this.action.id)"/>
      <!-- inverse binding, see design note in DecompositionClass.Binding -->
      <binding slot="$this.action"
               value="$this.action == undefined &amp;&amp; $demonstrate.type != undefined ?
                           TaskClass.get($demonstrate.type.getId()) : undefined"/>
      <binding slot="$learn.action"
               value="TaskClass.get($demonstrate.type.getId())"/>
      <binding slot="$learn.recipe" value="$this.recipe"/>
      <binding slot="$learn.external" value="$this.learner"/>

    </subtasks>

    <subtasks id="topdown">
      <step name="down" task="LearnRecipe"/>
      <step name="learn" task="addStep"/>
      <applicable> !$this.action.isPrimitive() </applicable>
      <binding slot="$down.action" value="$this.action"/>
      <binding slot="$down.learner" value="$this.learner"/>
      <binding slot="$learn.action" value="$down.action"/>
      <binding slot="$learn.recipe" value="$this.recipe"/>
      <binding slot="$learn.external" value="$this.learner"/>
    </subtasks>

  </task>
  
  <task id="addStep">
    <input name="action" type="TaskClass"/>
    <input name="recipe" type="DecompositionClass"/>
    <script>
      $this.recipe.steps.push($this.action);
    </script>
  </task>

  <script init="true">

    // using Javascript objects for convenience here, but will eventually
    // be able to construct actual ANSI/CEA-2018 instances on the fly

    var tasks = []; // known task classes
    var recipes = []; // known decomposition classes    

    function TaskClass (id) {
       this.id = id;
       tasks.push(this);
    }

    TaskClass.get = function (id) {  // factory method
       for (var i in tasks)
          if ( tasks[i].id === id ) return tasks[i];
       return new TaskClass(id);
    }
    
    TaskClass.prototype.toString = function () { return this.id; }

    TaskClass.prototype.isPrimitive = function () {
      var task = $disco.getTaskClass(this.id);
      if ( task != null ) return task.isPrimitive();
      for (var i in recipes)
         if ( recipes[i].goal == this ) return false;
      return true;
    }

    function DecompositionClass (id, goal) {
       this.id = id;
       this.goal = goal;
       this.steps = [];
       recipes.push(this);
    }

    DecompositionClass.get = function (id, goal) { // factory method
       for (var i in recipes)
          if ( recipes[i].id === id ) return recipes[i];
       return new DecompositionClass(id, goal);
    }
    
    DecompositionClass.prototype.isCompiled = function () {
      return $disco.getDecompositionClass(this.id) != null;
    }

    DecompositionClass.prototype.toString = function () {
       return this.id+
         (Packages.edu.wpi.cetask.TaskEngine.TRACE ? ("["+this.steps+"]") : "");
    }

    function hasRecipe (goal) {
       for (var i in recipes)
          if ( recipes[i].goal === goal ) return true;
       return false;
    }

    // compile newly learned task model elements to ANSI/CEA-2018 and load into Disco
    function compile (about) {
       Packages.edu.wpi.disco.ldt.UnifiedAgent.compileTasks(about, tasks);
       recipes.map(function(r) {
          Packages.edu.wpi.disco.ldt.UnifiedAgent.compileRecipe(r.id, r.goal,
            r.steps.map(function(s) { return s.id; })) });
       Packages.edu.wpi.disco.ldt.UnifiedAgent.load();
    }

  </script>
</taskModel>
