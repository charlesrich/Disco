<taskModel about="urn:disco.wpi.edu:ldt:Pedagogical"
           xmlns="http://www.cs.wpi.edu/~rich/cetask/cea-2018-ext">
  
  <!-- 
       This is the pedagogical model of the proof of concept system in
       a proposal submitted to the National Science Foundation
       in November, 2015, titled,

       A Unified Theory of Learning, Doing and Teaching Hierarchical Tasks:
       The Learn-Do-Teach Challenge for Collaborative Agents

       See Learn-Do-Teach.pdf (especially Figure 4) for technical discussion
       and test folder for test cases.

       See ABC.xml for the task model being taught.
  -->

  <!-- note 'task' is a reserved slot name in ANSI/CEA-2018, so 'action'
       is used instead below -->
       
  <task id="LearnRecipe">
    <input name="action" type="TaskClass"/>
    <input name="recipe" type="DecompositionClass"/>
    <input name="learner" type="boolean"/>

    <subtasks id="steps">
      <step name="step" task="LearnStep" maxOccurs="unbounded"/>
      <binding slot="$step.recipe" value="$this.recipe"/>
      <binding slot="$step.learner" value="$this.learner"/>
    </subtasks>

  </task>

  <task id="LearnStep">
    <input name="action" type="TaskClass"/>
    <input name="recipe" type="DecompositionClass"/>
    <input name="learner" type="boolean"/>

    <subtasks id="instruction">
      <step name="learn" task="addStep"/>
      <binding slot="$learn.action" value="$this.action"/>
      <binding slot="$learn.recipe" value="$this.recipe"/>
      <binding slot="$learn.external" value="$this.learner"/>
    </subtasks>

    <subtasks id="demonstration">
      <!-- note unrestricted step task type -->
      <step name="demonstrate"/>
      <step name="learn" task="addStep"/>
      <applicable> $this.action.isPrimitive() </applicable>
      <binding slot="$learn.action" value="new TaskClass($demonstrate.task)"/>
      <binding slot="$learn.recipe" value="$this.recipe"/>
      <binding slot="$learn.external" value="$this.learner"/>
    </subtasks>

    <subtasks id="topdown">
      <step name="down" task="LearnRecipe"/>
      <applicable> !$this.action.isPrimitive() </applicable>      
      <binding slot="$down.action" value="$this.action"/>
      <binding slot="$down.learner" value="$this.learner"/>
    </subtasks>

  </task>
  
  <task id="addStep">
    <input name="action" type="TaskClass"/>
    <input name="recipe" type="DecompositionClass"/>
    <script>
      $this.recipe.steps.push($this.action);
    </script>
  </task>

  <script init="true">

    // using Javascript objects for convenience here, but will eventually
    // be able to construct actual ANSI/CEA-2018 instances on the fly

    var tasks = []; // learned task classes
    var recipes = []; // learned decomposition classes    

    function TaskClass (id) {
       this.id = id;
       if ( !$disco.getTaskClass(this.id) ) tasks.push(this);
    }
    
    TaskClass.prototype.toString = function () {return this.id;}

    TaskClass.prototype.isPrimitive = function () {
      var task = $disco.getTaskClass(this.id);
      return task != null &amp;&amp; task.isPrimitive();
    }
      
    function DecompositionClass (id, goal) {
       this.id = id;
       this.goal = goal;
       this.steps = [];
       if ( !$disco.getDecompositionClass(this.id) ) recipes.push(this);
    }

    DecompositionClass.prototype.toString = function () {
       return this.id+
         (Packages.edu.wpi.cetask.TaskEngine.TRACE ? ("["+this.steps+"]") : "");
    }

    // compile learned task model into ANSI/CEA-2018 and load into Disco
    function compile (about) {
       Packages.edu.wpi.disco.ldt.UnifiedAgent.compileTasks(about, tasks);
       recipes.map(function(r) {
          Packages.edu.wpi.disco.ldt.UnifiedAgent.compileRecipe(r.id, r.goal,
            r.steps.map(function(s) { return s.id; })) });
            Packages.edu.wpi.disco.ldt.UnifiedAgent.load();
       tasks = []; recipes = [];
    }

  </script>
</taskModel>
